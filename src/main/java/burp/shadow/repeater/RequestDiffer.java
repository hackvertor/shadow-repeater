package burp.shadow.repeater;

import burp.api.montoya.http.message.HttpHeader;
import burp.api.montoya.http.message.params.HttpParameterType;
import burp.api.montoya.http.message.params.ParsedHttpParameter;
import burp.api.montoya.http.message.requests.HttpRequest;
import org.json.JSONArray;
import org.json.JSONObject;

import java.util.*;
import java.util.stream.Collectors;

import static burp.shadow.repeater.ShadowRepeaterExtension.settings;

public class RequestDiffer {
    public static Set<String> headersToSkip = Set.of("Content-Length");
    public static JSONArray generateHeadersAndParametersJson(HttpRequest[] requests) {
        JSONArray result = new JSONArray();
        if (requests == null || requests.length == 0) return result;
        HttpRequest[] requestsWithoutFilteredHeaders = filterHeaders(requests);
        boolean allIdentical = areAllRequestsIdentical(requestsWithoutFilteredHeaders);

        if (!allIdentical) {
            HttpRequest previous = null;
            for (int i = 0; i < requestsWithoutFilteredHeaders.length; i++) {
                HttpRequest current = requestsWithoutFilteredHeaders[i];
                if (i == 0) {
                    addAllItems(result, current);
                } else {
                    addDifferences(result, current, previous);
                }
                previous = current;
            }
            Set<String> inAll = intersectionOfAllRequests(requestsWithoutFilteredHeaders);
            result = filterNeverChangedItems(result, inAll);
            result = getMostFrequentParam(result);
        }

        return result;
    }

    private static HttpRequest[] filterHeaders(HttpRequest[] requests) {
        String[] excludedHeaders = Arrays.stream(settings.getString("Excluded headers").split(","))
                .map(String::trim)
                .toArray(String[]::new);
        HttpRequest[] filteredRequests = new HttpRequest[requests.length];
        for (int i = 0; i < requests.length; i++) {
            HttpRequest req = requests[i];
            for (String header : excludedHeaders) {
                req = req.withRemovedHeader(header.trim());
            }
            filteredRequests[i] = req;
        }
        return filteredRequests;
    }

    private static boolean areAllRequestsIdentical(HttpRequest[] requests) {
        for (int i = 1; i < requests.length; i++) {
            if (!requestsEquivalent(requests[0], requests[i])) return false;
        }
        return true;
    }

    private static boolean requestsEquivalent(HttpRequest a, HttpRequest b) {
        if (!a.pathWithoutQuery().equals(b.pathWithoutQuery())) return false;
        if (!a.headers().equals(b.headers())) return false;
        return parametersEqual(a.parameters(), b.parameters());
    }

    private static boolean parametersEqual(List<ParsedHttpParameter> listA, List<ParsedHttpParameter> listB) {
        if (listA.size() != listB.size()) return false;
        return parameterSet(listA).equals(parameterSet(listB));
    }

    private static Set<String> parameterSet(List<ParsedHttpParameter> params) {
        Set<String> set = new HashSet<>();
        for (ParsedHttpParameter p : params) {
            set.add(p.type() + "|" + p.name() + "|" + p.value());
        }
        return set;
    }

    private static void addAllItems(JSONArray result, HttpRequest request) {
        for (ParsedHttpParameter param : request.parameters()) {
            String type = parameterTypeText(param.type());
            if (!type.isEmpty()) {
                JSONObject obj = new JSONObject();
                obj.put("type", type);
                obj.put("name", param.name());
                obj.put("value", param.value());
                result.put(obj);
            }
        }
        String path = request.pathWithoutQuery();
        if (path.length() > 1) {
            JSONObject pathObj = new JSONObject();
            pathObj.put("type", "PATH");
            pathObj.put("value", path);
            result.put(pathObj);
        }
        List<HttpHeader> headers = new ArrayList<>(request.headers());
        if (!headers.isEmpty()) headers.removeFirst();
        for (HttpHeader h : headers) {
            if(headersToSkip.contains(h.name())) {
                continue;
            }
            JSONObject headerObj = new JSONObject();
            headerObj.put("type", "header");
            headerObj.put("name", h.name());
            headerObj.put("value", h.value());
            result.put(headerObj);
        }
    }

    private static void addDifferences(JSONArray result, HttpRequest current, HttpRequest previous) {
        String curPath = current.pathWithoutQuery();
        String prevPath = previous.pathWithoutQuery();
        if (!curPath.equals(prevPath)) {
            JSONObject pathObj = new JSONObject();
            pathObj.put("type", "PATH");
            pathObj.put("value", curPath);
            result.put(pathObj);
        }
        Set<String> curParams = parameterSet(current.parameters());
        Set<String> prevParams = parameterSet(previous.parameters());
        for (String curParam : curParams) {
            if (!prevParams.contains(curParam)) {
                String[] parts = curParam.split("\\|", 3);
                JSONObject obj = new JSONObject();
                obj.put("type", parameterTypeText(HttpParameterType.valueOf(parts[0])));
                obj.put("name", parts[1]);
                obj.put("value", parts[2]);
                result.put(obj);
            }
        }
        List<String> curHeaders = current.headers().stream().map((header) -> header.name() + ":" + header.value()).collect(Collectors.toList());
        List<String> prevHeaders = previous.headers().stream().map((header) -> header.name() + ":" + header.value()).collect(Collectors.toList());
        if (!curHeaders.isEmpty()) curHeaders.removeFirst();
        if (!prevHeaders.isEmpty()) prevHeaders.removeFirst();
        Set<String> curHeadersSet = new HashSet<>(curHeaders);
        Set<String> prevHeadersSet = new HashSet<>(prevHeaders);
        for (String header : curHeadersSet) {
            if (!prevHeadersSet.contains(header)) {
                String[] headerParts = header.split(":", 2);
                if(headerParts.length > 0) {
                    JSONObject headerObj = new JSONObject();
                    headerObj.put("type", "header");
                    headerObj.put("name", headerParts[0]);
                    if(headerParts.length > 1) {
                        headerObj.put("value", headerParts[1]);
                    } else {
                        headerObj.put("value", "");
                    }
                    if(!headersToSkip.contains(headerObj.getString("name"))) {
                        result.put(headerObj);
                    }
                }
            }
        }
    }

    private static String parameterTypeText(HttpParameterType type) {
        return switch (type) {
            case BODY -> "BODY";
            case COOKIE -> "COOKIE";
            case JSON -> "JSON";
            case URL -> "URL";
            default -> "";
        };
    }

    private static Set<String> buildRequestSet(HttpRequest req) {
        Set<String> set = new HashSet<>();
        for (ParsedHttpParameter p : req.parameters()) {
            String t = parameterTypeText(p.type());
            if (!t.isEmpty()) {
                set.add(t + "|" + p.name() + "|" + p.value());
            }
        }
        String path = req.pathWithoutQuery();
        if (path.length() > 1) {
            set.add("PATH|" + path);
        }
        List<HttpHeader> headers = new ArrayList<>(req.headers());
        if (!headers.isEmpty()) headers.removeFirst();
        for (HttpHeader h : headers) {
            set.add("header|" + h.name() + "|" + h.value());
        }
        return set;
    }

    private static Set<String> intersectionOfAllRequests(HttpRequest[] requests) {
        Set<String> intersection = null;
        for (HttpRequest r : requests) {
            Set<String> current = buildRequestSet(r);
            if (intersection == null) {
                intersection = new HashSet<>(current);
            } else {
                intersection.retainAll(current);
            }
            if (intersection.isEmpty()) break;
        }
        return intersection == null ? new HashSet<>() : intersection;
    }

    private static JSONArray filterNeverChangedItems(JSONArray result, Set<String> inAll) {
        JSONArray filtered = new JSONArray();
        for (int i = 0; i < result.length(); i++) {
            JSONObject obj = result.getJSONObject(i);
            String type = obj.optString("type");
            String name = obj.optString("name", "");
            String value = obj.optString("value", "");
            String key;
            if ("PATH".equals(type)) {
                key = type + "|" + value;
            } else {
                key = type + "|" + name + "|" + value;
            }
            if (!inAll.contains(key)) {
                filtered.put(obj);
            }
        }
        return filtered;
    }

    private static JSONArray getMostFrequentParam(JSONArray items) {
        HashMap<String, Integer> counts = new HashMap<>();
        for (int i = 0; i < items.length(); i++) {
            JSONObject obj = items.getJSONObject(i);
            String type = obj.optString("type");
            String name = obj.optString("name", "");
            String key;
            if ("PATH".equals(type)) {
                key = type;
            } else {
                key = type + "|" + name;
            }
            if(counts.containsKey(key)) {
                counts.put(key, counts.get(key) + 1);
            } else {
                counts.put(key, 1);
            }
        }
        Map.Entry<String, Integer> maxParam = null;

        for (Map.Entry<String, Integer> entry : counts.entrySet()) {
            if (maxParam == null || entry.getValue() > maxParam.getValue()) {
                maxParam = entry;
            }
        }
        JSONArray result = new JSONArray();
        if(maxParam == null) {
            return result;
        }
        for (int i = 0; i < items.length(); i++) {
            JSONObject obj = items.getJSONObject(i);
            String type = obj.optString("type");
            String name = obj.optString("name", "");
            String key;
            if ("PATH".equals(type)) {
                key = type;
            } else {
                key = type + "|" + name;
            }
            if(key.equals(maxParam.getKey())) {
                result.put(obj);
            }
        }
        return result;
    }
}
